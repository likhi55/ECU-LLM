# Implement soft/hard rev limiter with hysteresis (overspeed protection)

## SCR ID
SCR000010

## Objective
Prevent engine speed from exceeding calibrated limits by adding a **two‑stage rev
limiter** with hysteresis:
- **Soft limit:** holds speed at a calibrated ceiling.
- **Hard limit:** engages an aggressive cut when speed attempts to exceed a higher ceiling,
  then releases only after speed falls below a hysteresis band.

This sits on top of SCR2–SCR9 and does not change I/O schemas.

## Scope
- Builds on SCR000001–SCR000009.
- No new inputs or outputs.
- Introduces a small internal state for the hard‑cut latch.

## Inputs (from input CSV)
Unchanged:
```
time,ignition_switch,acc_pedal_position,brake_pedal_position,current_gear,cruise_enable,cruise_target_speed
```

## Outputs (to output CSV)
Unchanged:
```
time,engine_state,engine_speed
```

## Calibrations (append to `app/calibration/calibration.txt`)
- `rev_soft_limit = 1800`           # rpm ceiling for soft limit (≤ max_engine_speed)
- `rev_hard_limit = 1950`           # rpm ceiling for hard cut (≤ max_engine_speed, > soft limit)
- `rev_hysteresis = 50`             # rpm below the hard limit to release hard‑cut latch
- `rev_hard_cut_step = 60`          # rpm/row reduction while hard cut is active
- `rev_cut_cooldown_rows = 2`       # rows to continue hard cut after first trigger (minimum 0)

> Use `ECU_CALIB_PATH` to override the calibration file path at runtime.
> Any negative values are coerced to 0; ensure `rev_soft_limit < rev_hard_limit ≤ max_engine_speed`.

## Algorithm / Logic
Let:
- `prev_out` = engine speed **emitted on the previous row** (after SCR8, i.e., the true last output)
- `speed_tmp` = provisional speed after SCR2–SCR9 (accel/brake/gear, cruise, coastdown, idle, limp)

Maintain internal state across rows:
- `hard_cut_active` (0/1)
- `hard_cut_cooldown` (non‑negative int)

Per row (after reading inputs & calibrations):
1. If `engine_state == 0` → clear `hard_cut_active = 0`, `hard_cut_cooldown = 0`, output `0` (as before).
2. Compute `speed_tmp` via SCR2–SCR9 using `prev_out`.
3. **Hard limit & hysteresis:**
   - If `hard_cut_active == 1`:
     - `speed_tmp = min(speed_tmp, prev_out - rev_hard_cut_step)`
     - Decrement `hard_cut_cooldown` (if > 0).
     - If `prev_out <= rev_hard_limit - rev_hysteresis` **and** `hard_cut_cooldown == 0`, set `hard_cut_active = 0`.
   - Else (not active):
     - If `speed_tmp > rev_hard_limit` **or** `prev_out > rev_hard_limit`:
       - Set `hard_cut_active = 1`
       - Set `hard_cut_cooldown = rev_cut_cooldown_rows`
       - `speed_tmp = min(speed_tmp, rev_hard_limit)`
4. **Soft limit (ceiling):**
   - `speed_tmp = min(speed_tmp, rev_soft_limit)`
5. **Slew limiting (SCR8):**
   - Apply `apply_slew_limit(...)` vs `prev_out` to get final `engine_speed`.
6. Clamp and round as usual to `[0, max_engine_speed]`.

### Ordering
The rev limiter runs **after SCR9** and **before SCR8** each row. This ensures the limiter
defines the target while the slew limiter still governs per‑row changes.

## Edge Cases
- If `rev_soft_limit >= rev_hard_limit`, treat `rev_soft_limit = max(0, rev_hard_limit - 1)` at runtime.
- If `rev_hard_cut_step == 0`, hard cut will latch but not actively pull down; slew limiting and coastdown
  will govern the descent.
- On the very first processed row, `prev_out = 0`.
- All limits are additionally bounded by `max_engine_speed`.

## Acceptance Criteria
- With aggressive throttle or cruise, speed never exceeds `rev_soft_limit` under normal conditions.
- If speed would surpass `rev_hard_limit`, the hard cut latches and pulls speed down by
  `rev_hard_cut_step` per row until `prev_out <= rev_hard_limit - rev_hysteresis` and cooldown expires.
- Ignition OFF immediately clears the hard cut state.
- Output schema and row alignment unchanged.

## Testcases (to be added under `testcases/SCR000010/`)
- **case1 Soft cap:** Ramp with high throttle; verify speed plateaus at `rev_soft_limit` (never exceeds it).
- **case2 Hard overspeed:** Use tighter limits (e.g., soft=1700, hard=1750) to trigger hard cut; verify latch + pull‑down then release after hysteresis.
- **case3 Clear on OFF:** Trigger hard cut, then set ignition OFF for a row; after ON, limiter state is clear.
- **case4 Cruise interaction:** Cruise to high target; verify soft cap holds and, if exceeded, hard cut behavior engages and dominates cruise.
- **case5 Edge values:** Set `rev_hard_cut_step=0` and verify latch without active pull; descent governed by coastdown/slew.

## File & Repo Changes
- **Code:**
  - Parse the five rev‑limiter calibrations.
  - Add two run‑time state variables: `hard_cut_active`, `hard_cut_cooldown` (kept within the `app/app.c` process).
  - Insert limiter after SCR9 and before SCR8.
- **Calibration:** append keys listed above.
- **Tests:** add cases described above with golden outputs.
- **Docs:** this file `scr/SCR000010.md`.

## Definition of Done
- PR links and closes the SCR issue (`Closes #<issue-id>`).
- CI green on PR and `main`.
- All SCR10 testcases pass golden comparison.
- Tag created: `SCR_000010_implemented` (or included in next Release).
