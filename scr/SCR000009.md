# Implement pedal plausibility & limp mode (latched safety cap)

## SCR ID
SCR000009

## Objective
Detect **implausible pedal overlap** (accelerator and brake pressed together beyond thresholds)
and enter a **limp mode** that limits engine response to a safe cap until ignition is turned OFF.
This adds a safety layer on top of SCR2–SCR8 without changing the output schema.

## Scope
- Builds on SCR000001–SCR000008.
- No new output columns. No new input columns (uses existing `acc_pedal_position` and `brake_pedal_position`).
- Limp mode **latches** once triggered and clears when ignition becomes OFF (engine_state=0).
- When limp is active:
  - Cap final speed to `limp_max_speed` rpm (applied before slew limiting).
  - Reduce effective acceleration response by scaling (`limp_acc_gain_scale`), optional but recommended.

## Inputs (from input CSV)
Unchanged:
```
time,ignition_switch,acc_pedal_position,brake_pedal_position,current_gear,cruise_enable,cruise_target_speed
```

## Outputs (to output CSV)
Unchanged:
```
time,engine_state,engine_speed
```

## Calibrations (append to `app/calibration/calibration.txt`)
- `acc_overlap_deg = 10`           # min accelerator degrees to consider overlap
- `brk_overlap_deg = 10`           # min brake degrees to consider overlap
- `limp_rows_confirm = 2`          # consecutive rows of overlap to enter limp
- `limp_max_speed = 300`           # rpm cap while limp is active
- `limp_acc_gain_scale = 0.3`      # scale factor on accel effect in limp (0..1)
- `limp_clear_on_ignition_off = 1` # when ignition OFF, clear limp latch (0/1)

> Use `ECU_CALIB_PATH` to override calibration path at runtime.

## Algorithm / Logic
Let `overlap(acc,brk)` be true if `acc >= acc_overlap_deg` **and** `brk >= brk_overlap_deg`.
Maintain two internal states across rows: `limp_mode (0/1)` and `overlap_run_count`.

Per-row sequence (after reading inputs & calibrations):
1. Compute `engine_state` (SCR1). If `engine_state == 0`:
   - `limp_mode = 0` if `limp_clear_on_ignition_off == 1`.
   - Output `engine_speed = 0` (as before) and continue.
2. Update overlap counter:
   - If `overlap(acc,brk)` → `overlap_run_count++` else `overlap_run_count = 0`.
   - If `overlap_run_count >= limp_rows_confirm` → set `limp_mode = 1` (latched).
3. **Baseline pipeline**: compute provisional speed with SCR2–SCR7:
   - acceleration/brake/gear (SCR2–SCR4),
   - cruise (SCR5),
   - coastdown (SCR6),
   - idle (SCR7) → `speed_tmp`.
   - If `limp_mode == 1`, scale the **accel delta** by `limp_acc_gain_scale` prior to step 3; alternatively, clamp `speed_tmp` post‑calc (see below). Minimal implementation may just clamp.
4. **Limp enforcement**:
   - If `limp_mode == 1` then
     - `speed_tmp = min(speed_tmp, limp_max_speed)`
5. **Slew limiting (SCR8)**:
   - Apply rate limit vs **previous output** to get final `engine_speed`.

### Minimal vs. full implementation
- **Minimal**: keep existing accel computation, only apply speed clamp in step 4.
- **Full**: when limp is active, also scale the acceleration term by `limp_acc_gain_scale` inside the SCR2–SCR4 portion to make ramps gentler.

## Edge Cases
- If pedals overlap for one row but not consecutively up to `limp_rows_confirm`, limp does not latch.
- Once in limp, lifting either pedal does **not** clear limp; only ignition OFF clears it (if enabled by calibration).
- `limp_acc_gain_scale` values <0 are coerced to 0; >1 are clamped to 1.
- `limp_max_speed` is additionally bounded by `max_engine_speed`.

## Acceptance Criteria
- With sustained overlap (≥ `limp_rows_confirm` rows), subsequent rows are capped at `limp_max_speed` despite high accelerator or cruise requests.
- Ignition OFF clears limp (if configured), and normal operation resumes on next ON cycle.
- Output schema and row count unchanged.
- Golden tests show latch behavior, capped speed, and proper clear on ignition OFF.

## Testcases (to be added under `testcases/SCR000009/`)
- **case1 (latch)**: Overlap for 2 rows from rest, continue with throttle only → verify cap at `limp_max_speed`.
- **case2 (no latch)**: Single-row overlap pulses separated by non-overlap rows → no limp.
- **case3 (clear on OFF)**: Enter limp, then rows with ignition OFF → limp clears; on ON, normal operation resumes.
- **case4 (cruise + limp)**: Cruise enabled after limp latched → clamp still applies, limiter dominates.
- **case5 (scale optional)**: With `limp_acc_gain_scale=0.3`, ramps are gentler under limp vs. 1.0.

## File & Repo Changes
- **Code**:
  - Parse calibrations: `acc_overlap_deg`, `brk_overlap_deg`, `limp_rows_confirm`, `limp_max_speed`, `limp_acc_gain_scale`, `limp_clear_on_ignition_off`.
  - Add per-run state: `limp_mode` (static in process) and `overlap_run_count`.
  - Hook detection before provisional speed, enforce cap before SCR8 slew limiting.
- **Calibration**: append the keys above.
- **Tests**: add testcases as listed.
- **Docs**: this file `scr/SCR000009.md`.

## Definition of Done
- PR links and closes the SCR issue (`Closes #<issue-id>`).
- CI green on PR and `main`.
- All SCR9 testcases pass golden comparison.
- Tag created: `SCR_000009_implemented` (or included in next Release).
