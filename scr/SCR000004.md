# Implement gear-based acceleration scaling

## SCR ID
SCR000004

## Objective
Introduce **gear logic** that scales acceleration based on the selected gear. This SCR:
- Adds a new input `current_gear` (integer 1–5).
- Scales the accelerator effect from SCR2 using per-gear multipliers.
- Keeps the output schema `time,engine_state,engine_speed` unchanged.

## Scope
- Builds on SCR000001 (ignition), SCR000002 (accelerator), SCR000003 (brake).
- CSV I/O unchanged; only input header gains `current_gear`.
- No clutch/shift latency modeling in this SCR (may be added later).

## Assumptions
- `engine_state` is computed by SCR1: 1 when ignition ON, else 0.
- Base acceleration gain from SCR2 is `acc_base_gain_rpm_per_deg = 2` rpm/deg.
- Brake deceleration from SCR3 is active and applied each iteration.
- `current_gear` outside 1–5 is clamped to the nearest valid gear.

## Inputs (from input CSV)
- `time` (integer; optional; autogenerated 0..N-1 if absent)
- `ignition_switch` (0 or 1)
- `acc_pedal_position` (degrees, integer, 0–45)
- `brake_pedal_position` (degrees, integer, 0–45)
- `current_gear` (integer, 1–5)  **← new**

## Outputs (to output CSV)
- `time` (integer)
- `engine_state` (0 or 1)
- `engine_speed` (rpm, integer, 0..max_engine_speed)

## Calibrations
Add the following keys to `app/calibration/calibration.txt` (allow floats). If a key is missing, use the default value.
- `max_engine_speed = 2000` *(existing)*
- `brake_gain_rpm_per_deg = 4` *(existing)*
- **Per-gear multipliers** (defaults in parentheses):
  - `gear_acc_multiplier_g1 = 0.6`
  - `gear_acc_multiplier_g2 = 0.85`
  - `gear_acc_multiplier_g3 = 1.00`
  - `gear_acc_multiplier_g4 = 1.10`
  - `gear_acc_multiplier_g5 = 1.20`

> Effective accel gain per degree in gear *g*:  

> `gain_deg(g) = acc_base_gain_rpm_per_deg * gear_acc_multiplier_g`

## Algorithm / Logic
Let `engine_speed_prev` be last iteration’s speed.

1. Compute `engine_state` (SCR1). If `engine_state == 0`: `engine_speed = 0` and continue.
2. Clamp inputs:
   - `acc = clamp(acc_pedal_position, 0, 45)`
   - `brk = clamp(brake_pedal_position, 0, 45)`
   - `g   = clamp(current_gear, 1, 5)`
3. Gains:
   - `gain_acc = acc_base_gain_rpm_per_deg * gear_acc_multiplier_g`
   - `delta_acc = acc * gain_acc`
   - `delta_brk = brk * brake_gain_rpm_per_deg`
4. Update & saturate:
   - `engine_speed_tmp = engine_speed_prev + delta_acc - delta_brk`
   - `engine_speed = clamp(round(engine_speed_tmp), 0, max_engine_speed)`

### Pseudocode
```
engine_state = ignition_switch ? 1 : 0
if engine_state == 0:
    engine_speed = 0
else:
    acc = clamp(acc_pedal_position, 0, 45)
    brk = clamp(brake_pedal_position, 0, 45)
    g   = clamp(current_gear, 1, 5)

    gain_acc = acc_base_gain_rpm_per_deg * gear_acc_multiplier[g]
    delta_acc = acc * gain_acc
    delta_brk = brk * brake_gain_rpm_per_deg

    engine_speed = clamp(engine_speed_prev + delta_acc - delta_brk, 0, max_engine_speed)
```

## I/O CSV Schemas
**Input**
```
time,ignition_switch,acc_pedal_position,brake_pedal_position,current_gear
```
**Output**
```
time,engine_state,engine_speed
```

## Edge Cases
- Gear out of range: clamp to [1..5].
- Rapid gear flips: allowed; no latency modeled in this SCR.
- Ignition OFF row: speed forced to 0 regardless of pedals or gear.
- Overflow/underflow guarded by `clamp()`.
- Missing required fields should produce non-zero exit and error on stderr.

## Acceptance Criteria
- With ignition ON, higher gears (4–5) produce larger acceleration than gear 3 for the same pedal input; lower gears (1–2) produce less, per multipliers.
- With ignition OFF, speed remains 0.
- With brake applied, net change equals `delta_acc(g) - delta_brk` per row, clipped to bounds.
- Output header exactly `time,engine_state,engine_speed` and row count matches input.

## Testcases (to be added)
- **case1:** Constant acc=10°, brake=0, compare gear=1 vs gear=3 vs gear=5 (in separate runs) to see scaled ramps.
- **case2:** Gear change mid-run (e.g., 1→3→5) with acc held constant; verify slope increases at change points.
- **case3:** With brake engaged (e.g., acc=20°, brake=10°) across gears; verify net change reduces but still respects gear scaling.
- **case4:** Saturation at `max_engine_speed` in high gear with sustained acc.
- **case5:** OFF rows reset speed to 0, then resume ramp with current gear after ON.

## File & Repo Changes
- **Code:**
  - Parse `current_gear` column.
  - Load `gear_acc_multiplier_g1..g5` (floats) from calibration; default as above.
  - Compute gear-scaled acceleration and integrate with existing brake logic.
- **Calibration:**
  - Add the new multiplier keys to `app/calibration/calibration.txt`.
- **Tests:**
  - Add `testcases/SCR000004/case*/{caseN.csv,golden.csv}` matching the scenarios above.
- **Docs:**
  - This file at `scr/SCR000004.md`.

## Definition of Done
- PR links and closes the SCR issue (`Closes #<issue-id>`).
- CI green on PR and `main`.
- All SCR4 testcases pass golden comparison.
- Tag created: `SCR_000004_implemented` (or included in next Release tag).
